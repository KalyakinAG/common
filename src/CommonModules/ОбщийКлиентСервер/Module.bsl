#Область ПрограммныйИнтерфейс

#Область РаботаСоСтроками

//  Преобразование текста HTML в форматированную строку
//
//  Поддерживаются теги:
//    <p> - абзац
//    <br> - перевод строки
//    <n> - шрифт без оформления
//    <b> - жирный шрифт
//    <i> - наклонный шрифт
//    <u> - подчеркнутый шрифт
//    <s> - зачеркнутый шрифт
//    <img src = "{ИмяКартинкиИзБиблиотекиКартинок}">
//  Поддерживаются стили: 
//    font-weight: bold|normal
//    font-style: italic|normal
//    text-decoration: underline|line-through|none
//    font-family: {ИмяШрифта}
//    font-size: {РазмерШрифта}
//    font-scale: {МасштабШрифта}
//    color: {ЦветТекста}
//    background-color: {ЦветФона}
//  Примеры:
//    <i color="blue">Цветная</i>
//    <span style="font-size: 18">Меняем размер шрифта</span>
//    <span style="font-family: consolas">Меняем шрифт</span>
//    <span style="background-color: yellow; color: red">красный текст на <i>желтом</i> фоне</span>
//
//  Параметры:
//  ТекстHTML - Строка - Строка в формате HTML
//  Вложения - Структура - 
//		* Ключ - имя картинки в HTML, 
//		* Значение - картинка
//
// Возвращаемое значение:
//  ФорматированнаяСтрока
Функция HTMLШаблон(ТекстHTML, Знач Вложения = Неопределено) Экспорт
	Вложения = ?(Вложения = Неопределено, Новый Структура, Вложения);
	ФорматированныйДокумент = Новый ФорматированныйДокумент;
	ФорматированныйДокумент.УстановитьHTML(ТекстHTML, Вложения);
	Возврат ФорматированныйДокумент.ПолучитьФорматированнуюСтроку();
КонецФункции

// Camel case.
// 
// Параметры:
//  Строка - Строка
// 
// Возвращаемое значение:
//  Строка - Camel case
Функция CamelCase(Строка) Экспорт
	Состав = СтрРазделить(Строка, " ", Ложь);
	Для й = 0 По Состав.ВГраница() Цикл
		Слово = Состав[й];
		Состав[й] = ВРег(Лев(Слово, 1)) + НРег(Прав(Слово, СтрДлина(Слово) - 1));
	КонецЦикла;
	Возврат СтрСоединить(Состав, "");
КонецФункции

// Экранировать текст
// Заменяет перенос строки на "|", кавычки на двойные кавычки
// 
// Параметры:
//  ТекстоваяСтрока - Строка - Текстовая строка
// 
// Возвращаемое значение:
//  Строка - Экранировать текст
Функция ЭкранироватьТекст(Знач ТекстоваяСтрока) Экспорт
	ТекстоваяСтрока = СтрЗаменить(ТекстоваяСтрока, Символы.ПС, Символы.ПС+"|");
	ТекстоваяСтрока = СтрЗаменить(ТекстоваяСтрока, """", """""");
	Возврат ТекстоваяСтрока;
КонецФункции

// Возвращает эквивалент имени по значению уникального идентификатора
//
// Параметры:
//  УИД - УникальныйИдентификатор - Значение уникального идентификатора
//
// Возвращаемое значение:
//  Строка - имя удовлетворяющее требованиям имен переменных
//
Функция ИмяПоУникальномуИдентификатору(Знач УИД = Неопределено) Экспорт
	Если УИД = Неопределено Тогда
		УИД = Новый УникальныйИдентификатор;
	КонецЕсли;
	Возврат "_" + СтрЗаменить(Строка(УИД), "-", "_");
КонецФункции

Функция ОкончаниеСтрокиПослеРазделителя(Строка, Разделитель = ".") Экспорт
	Возврат Сред(Строка, СтрНайти(Строка, Разделитель, НаправлениеПоиска.СКонца)+1);
КонецФункции

Функция НачалоСтрокиПослеРазделителя(Строка, Разделитель = ".") Экспорт
	Возврат Сред(Строка, СтрНайти(Строка, Разделитель, НаправлениеПоиска.СНачала)+1);
КонецФункции

#КонецОбласти

#Область ОбработкаОшибок

Функция ПолучитьТекстОшибок(Ошибки, Отказ = Ложь) Экспорт
	Если Ошибки = Неопределено Тогда
		Возврат "";
	Иначе
		Отказ = Истина;
	КонецЕсли; 
	ТекстОшибок = "";
	Для каждого Ошибка Из Ошибки.СписокОшибок Цикл
		Если Ошибки.ГруппыОшибок[Ошибка.ГруппаОшибок] <> Истина Тогда
			ТекстОшибок = ТекстОшибок + Символы.ПС + Ошибка.ТекстДляОднойОшибки;
		Иначе
			Текст = ?(ПустаяСтрока(Ошибка.ТекстДляНесколькихОшибок), Ошибка.ТекстДляОднойОшибки, Ошибка.ТекстДляНесколькихОшибок);
			ТекстОшибок = ТекстОшибок + Символы.ПС + СтрЗаменить(Текст, "%1", Формат(Ошибка.НомерСтроки + 1, "ЧН=0; ЧГ="));
		КонецЕсли;
	КонецЦикла;
	ТекстОшибок = Прав(ТекстОшибок, СтрДлина(ТекстОшибок)-1);
	Возврат ТекстОшибок;
КонецФункции

// Выводит накопленные методом ДобавитьОшибкуПользователю ошибки, при этом использует нужные шаблоны текстов ошибок
// в зависимости от количества однотипных ошибок.
//
// Параметры:
//  Ошибки  - Неопределено, Структура - коллекция ошибок.
//  Отказ - Булево - устанавливается Истина, если ошибки сообщались.
//
Процедура СообщитьОшибкиПользователю(Ошибки, Отказ = Ложь, Заголовок = "", Подвал = "") Экспорт
	Если Ошибки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если НЕ ПустаяСтрока(Заголовок) Тогда
		Отступ = "	";
		ОбщегоНазначенияСлужебныйКлиентСервер.СообщитьПользователю(Заголовок, Неопределено, "");
	Иначе
		Отступ = "";
	КонецЕсли;
	Отказ = Истина;
	Для каждого Ошибка Из Ошибки.СписокОшибок Цикл
		Если Ошибка.ИндексСтроки = Неопределено Тогда
			ИндексСтроки = Ошибка.НомерСтроки;
		Иначе
			ИндексСтроки = Ошибка.ИндексСтроки;
		КонецЕсли;
		Если Ошибки.ГруппыОшибок[Ошибка.ГруппаОшибок] <> Истина Тогда
			ОбщегоНазначенияСлужебныйКлиентСервер.СообщитьПользователю(
				Отступ + Ошибка.ТекстДляОднойОшибки,
				Неопределено,
				СтрЗаменить(Ошибка.ПолеОшибки, "%1", Формат(ИндексСтроки, "ЧН=0; ЧГ=")));
		Иначе
			ОбщегоНазначенияСлужебныйКлиентСервер.СообщитьПользователю(
				Отступ + СтрЗаменить(Ошибка.ТекстДляНесколькихОшибок, "%1", Формат(Ошибка.НомерСтроки + 1, "ЧН=0; ЧГ=")),
				Неопределено,
				СтрЗаменить(Ошибка.ПолеОшибки, "%1", Формат(ИндексСтроки, "ЧН=0; ЧГ=")));
		КонецЕсли;
	КонецЦикла;
	Если НЕ ПустаяСтрока(Подвал) Тогда
		ОбщегоНазначенияСлужебныйКлиентСервер.СообщитьПользователю(Подвал, Неопределено, "");
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область РаботаСФайлами

Функция ДобавитьКонечныйРазделительПути(Знач ПутьКаталога) Экспорт
	Если ПустаяСтрока(ПутьКаталога) Тогда
		Возврат ПутьКаталога;
	КонецЕсли;
	ДобавляемыйСимвол = ПолучитьРазделительПути();
	Если СтрЗаканчиваетсяНа(ПутьКаталога, ДобавляемыйСимвол) Тогда
		Возврат ПутьКаталога;
	Иначе 
		Возврат ПутьКаталога + ДобавляемыйСимвол;
	КонецЕсли;
КонецФункции

// Объединить пути.
// 
// Параметры:
//  Путь1 - Строка - Путь1
//  Путь2 - Строка - Путь2
//  Путь3 - Строка - Путь3
//  Путь4 - Строка - Путь4
//  Путь5 - Строка - Путь5
// 
// Возвращаемое значение:
//  Строка - Объединенный путь
Функция ОбъединитьПути(Путь1, Путь2, Путь3 = "", Путь4 = "", Путь5 = "") Экспорт
	Состав = Новый Массив;
	Если ЗначениеЗаполнено(Путь1) Тогда
		Состав.Добавить(ДобавитьКонечныйРазделительПути(Путь1));
	КонецЕсли;
	Если ЗначениеЗаполнено(Путь2) Тогда
		Состав.Добавить(ДобавитьКонечныйРазделительПути(Путь2));
	КонецЕсли;
	Если ЗначениеЗаполнено(Путь3) Тогда
		Состав.Добавить(ДобавитьКонечныйРазделительПути(Путь3));
	КонецЕсли;
	Если ЗначениеЗаполнено(Путь4) Тогда
		Состав.Добавить(ДобавитьКонечныйРазделительПути(Путь4));
	КонецЕсли;
	Если ЗначениеЗаполнено(Путь5) Тогда
		Состав.Добавить(ДобавитьКонечныйРазделительПути(Путь5));
	КонецЕсли;
	Результат = СтрСоединить(Состав);
	Возврат Лев(Результат, СтрДлина(Результат) - 1);
КонецФункции

Функция ФайлСуществует(Знач ПутьКФайлу) Экспорт
	Файл = Новый Файл(ПутьКФайлу);
	Если Не Файл.Существует() Тогда
		Возврат Ложь;
	КонецЕсли;
	Если Файл.ЭтоФайл() Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

#КонецОбласти

#Область РаботаСоСтруктурой
// Словарь отображения свойств
// Преобразует строку соответствия свойств в структуру (словарь) ИсходноеСвойство = КонечноеСвойство
// 
// Параметры:
//  СоответствиеСвойств - Строка - описание соответствия свойств ИсходноеСвойство = КонечноеСвойство
// 
// Возвращаемое значение:
//  Структура - Словарь отображения свойств
Функция СловарьОтображенияСвойств(СоответствиеСвойств) Экспорт
	Если ТипЗнч(СоответствиеСвойств) = Тип("Структура") Тогда
		Возврат СоответствиеСвойств;
	КонецЕсли;
	Словарь = Новый Структура;
	Для Каждого Свойство Из РаботаСМассивом.Массив(СоответствиеСвойств) Цикл
		Состав = СтрРазделить(Свойство, "= ", Ложь);
		Если Состав.Количество() = 1 Тогда
			Словарь.Вставить(Состав[0], Состав[0]);
			Продолжить;						
		КонецЕсли;
		Словарь.Вставить(Состав[1], Состав[0]);
	КонецЦикла;
	Возврат Словарь;
КонецФункции

// Отобразить свойства.
// 
// Параметры:
//  Источник - Структура, Соответствие из Произвольный - источник свойств
//  СоответствиеСвойств - Строка - описание соответствия свойств ИсходноеСвойство = КонечноеСвойство
// 
// Возвращаемое значение:
//  Структура
Функция ОтобразитьСвойства(Источник, СоответствиеСвойств) Экспорт
	СловарьОтображения = СловарьОтображенияСвойств(СоответствиеСвойств);
	НовоеЗначение = Новый Структура();
	Для Каждого Отображение Из СловарьОтображения Цикл
		НовоеЗначение.Вставить(Отображение.Значение, Источник[Отображение.Ключ]);
	КонецЦикла;
	Возврат НовоеЗначение;
КонецФункции

// Представление структуры.
// 
// Параметры:
//  Структура - Структура
// 
// Возвращаемое значение:
//  Строка - Представление структуры
Функция ПредставлениеСтруктуры(Структура) Экспорт
	Поля = РаботаСМассивом.АТДМассив(Структура)
		.Отобразить("СтрШаблон('%1: """"%2""""', Элемент.Ключ, Строка(Элемент.Значение))")
		.ВМассив()
	;
	Представление = "{
	|	" + СтрСоединить(Поля, Символы.ПС + Символы.Таб) + "
	|}";
	Возврат Представление;
КонецФункции

// Вставить свойство
// 
// Параметры:
//  Приемник 	- Структура
//  			- Соответствие из Произвольный - 
//  Свойство - Строка
//  Значение - Произвольный
// 
// Возвращаемое значение:
//  Структура, Соответствие из Произвольный - приемник с новым свойством
Функция ВставитьСвойство(Приемник, Свойство, Значение) Экспорт
	Приемник.Вставить(Свойство, Значение);
	Возврат Приемник;
КонецФункции

// Вставить свойство
// 
// Параметры:
//  Приемник 	- Структура
//  			- Соответствие из Произвольный - 
//  ПутьКДанным - Строка
//  Значение - Произвольный
// 
// Возвращаемое значение:
//  Структура, Соответствие из Произвольный - приемник с новым свойством
Функция ВставитьСвойствоРекурсивно(Приемник, ПутьКДанным, Значение) Экспорт
	Если ТипЗнч(Приемник) = Тип("Соответствие") Тогда
		Возврат ВставитьСвойствоСоответствия(Приемник, ПутьКДанным, Значение);
	ИначеЕсли ТипЗнч(Приемник) = Тип("Структура") Тогда
		Возврат ВставитьСвойствоСтруктуры(Приемник, ПутьКДанным, Значение);
	Иначе
		ВызватьИсключение "Неверный тип приемника";
	КонецЕсли;
КонецФункции

// Вставить свойство
// 
// Параметры:
//  Приемник - Соответствие из Произвольный - 
//  ПутьКДанным - Строка
//  Значение - Произвольный
// 
// Возвращаемое значение:
//  Соответствие из Произвольный - приемник с новым свойством
Функция ВставитьСвойствоСоответствия(Приемник, ПутьКДанным, Значение) Экспорт
	СоставПути = СтрРазделить(ПутьКДанным, ".");
	Узел = Приемник;
	Для Индекс = 0 По СоставПути.ВГраница() - 1 Цикл
		Свойство = СоставПути[Индекс];
		ПодчиненныйУзел = Узел[Свойство];		
		Если ПодчиненныйУзел = Неопределено Тогда
			ПодчиненныйУзел = Новый Соответствие;
			Узел.Вставить(Свойство, ПодчиненныйУзел);
		КонецЕсли;
		Узел = ПодчиненныйУзел;
	КонецЦикла;
	Свойство = СоставПути[СоставПути.ВГраница()]; 
	Узел.Вставить(Свойство, Значение);
	Возврат Приемник;
КонецФункции

// Вставить свойство
// 
// Параметры:
//  Приемник - Структура - 
//  ПутьКДанным - Строка - 
//  Значение - Произвольный - 
// 
// Возвращаемое значение:
//  Структура - приемник с новым свойством
Функция ВставитьСвойствоСтруктуры(Приемник, ПутьКДанным, Значение) Экспорт
	Перем ПодчиненныйУзел;
	СоставПути = СтрРазделить(ПутьКДанным, ".");
	Узел = Приемник;
	Для Индекс = 0 По СоставПути.ВГраница() - 1 Цикл
		Свойство = СоставПути[Индекс];		
		Если НЕ Узел.Свойство(Свойство, ПодчиненныйУзел) Тогда
			ПодчиненныйУзел = Новый Структура;
			Узел.Вставить(Свойство, ПодчиненныйУзел);
		КонецЕсли;
		Узел = ПодчиненныйУзел;
	КонецЦикла;
	Свойство = СоставПути[СоставПути.ВГраница()]; 
	Узел.Вставить(Свойство, Значение);
	Возврат Приемник;
КонецФункции

// Структура различий.
// 
// Параметры:
//  Структура1 - Структура
//  Структура2 - Структура
// 
// Возвращаемое значение:
//  Структура - Структура различий
Функция СтруктураРазличий(Структура1, Структура2) Экспорт
	Перем Значение;
	СтруктураРазличий = Новый Структура;
	Для Каждого ЭлементСтруктуры Из Структура1 Цикл
		Если Не Структура2.Свойство(ЭлементСтруктуры.Ключ, Значение) ИЛИ Значение <> ЭлементСтруктуры.Значение Тогда
			СтруктураРазличий.Вставить(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
		КонецЕсли;
	КонецЦикла;
	Для Каждого ЭлементСтруктуры Из Структура2 Цикл
		Если Не Структура1.Свойство(ЭлементСтруктуры.Ключ, Значение) ИЛИ Значение <> ЭлементСтруктуры.Значение Тогда
			СтруктураРазличий.Вставить(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
		КонецЕсли;
	КонецЦикла;
	Возврат СтруктураРазличий;
КонецФункции

// Структуры идентичны.
// 
// Параметры:
//  Структура1 - Структура
//  Структура2 - Структура
// 
// Возвращаемое значение:
//  Булево
Функция СтруктурыИдентичны(Структура1, Структура2) Экспорт
	Возврат СтруктураРазличий(Структура1, Структура2).Количество() = 0;
КонецФункции

// Скопировать структуру.
// Не рекурсивное копирование структуры по списку свойств
// Параметры:
//  Источник - Структура
//  Свойства - Строка - Свойства
// 
// Возвращаемое значение:
//  Структура
Функция СкопироватьСтруктуру(Источник, Свойства) Экспорт
	Результат = Новый Структура(Свойства);
	ЗаполнитьЗначенияСвойств(Результат, Источник);
	Возврат Результат;
КонецФункции

// Установить свойство
// 
// Параметры:
//  Объект - Структура, Соответствие из Произвольный - 
//  Свойство - Строка - имя свойства
//  Значение - Произвольный
// 
// Возвращаемое значение:
//  Структура, Соответствие из Произвольный - исходная коллекция с новым свойством
Функция УстановитьСвойство(Объект, Свойство, Значение) Экспорт
	Объект[Свойство] = Значение;
	Возврат Объект;
КонецФункции

#КонецОбласти

#Область СериализацияJSON

#Если НЕ ВебКлиент Тогда

// Преобразует значение в строку JSON при помощи метода глобального контекста ЗаписатьJSON.
// Допускаются не все типы значений, подробности см. в синтакс-помощнике.
// Даты преобразуются в формат ISO (YYYY-MM-DDThh:mm:ssZ).
// 
// Параметры:
//  Значение - Произвольный
//  КрасивоеФорматирование - Булево - Красивое форматирование
//
// Возвращаемое значение:
//  Строка
//
Функция ЗначениеВJSON(Знач Значение, КрасивоеФорматирование = Ложь) Экспорт
	ЗаписьJSON = Новый ЗаписьJSON;
	Если КрасивоеФорматирование Тогда
		ЗаписьJSON.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Unix, "    ", Истина));
	Иначе
		ЗаписьJSON.УстановитьСтроку();
	КонецЕсли;
	ЗаписатьJSON(ЗаписьJSON, Значение);
	Возврат ЗаписьJSON.Закрыть();
КонецФункции

// Преобразует строку в формате JSON в значение при помощи метода глобального контекста ПрочитатьJSON.
// См. ограничения в синтакс-помощнике.
// Объекты JSON по умолчанию преобразует в значения типа Соответствие. 
// Имена свойств со значением типа Дата необходимо явно указывать, чтобы было выполнено преобразование.
// Ожидаемый формат дат - ISO (YYYY-MM-DDThh:mm:ssZ).
// 
// Параметры:
//   Строка - Строка - значение в формате JSON.
//   ИменаСвойствСоЗначениямиДата - Строка - имя свойства, содержащее значение типа Дата. Допустимо указывать несколько
//                                           свойств через запятую.
//                                - Массив из Строка 
//   ПрочитатьВСоответствие       - Булево - если Ложь, то объекты JSON будут преобразованы в значение типа Структура.
//   
// Возвращаемое значение:
//  Произвольный
//
Функция JSONВЗначение(Знач Строка, Знач ИменаСвойствСоЗначениямиДата = Неопределено, Знач ПрочитатьВСоответствие = Истина) Экспорт
	Если ТипЗнч(ИменаСвойствСоЗначениямиДата) = Тип("Строка") Тогда
		ИменаСвойствСоЗначениямиДата = СтрРазделить(ИменаСвойствСоЗначениямиДата, ", " + Символы.ПС, Ложь);
	КонецЕсли;
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(Строка);
	Возврат ПрочитатьJSON(ЧтениеJSON, ПрочитатьВСоответствие, ИменаСвойствСоЗначениямиДата);
КонецФункции

Функция ПрочитатьЗначениеJSONИзФайла(ИмяФайла) Экспорт
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.ОткрытьФайл(ИмяФайла, "UTF-8");
	Значение = ПрочитатьJSON(ЧтениеJSON);
	ЧтениеJSON.Закрыть();
	Возврат Значение;
КонецФункции

Процедура ЗаписатьЗначениеJSONВФайл(Значение, ИмяФайла) Экспорт
	ПараметрыJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, " ", Истина);
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.ОткрытьФайл(ИмяФайла, "UTF-8", , ПараметрыJSON);
	ЗаписатьJSON(ЗаписьJSON, Значение);
	ЗаписьJSON.Закрыть();
КонецПроцедуры

Функция ПрочитатьЗначениеJDTOИзФайла(ИмяФайла) Экспорт
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.ОткрытьФайл(ИмяФайла, "UTF-8");
	Значение = СериализаторXDTO.ПрочитатьJSON(ЧтениеJSON);
	Возврат Значение;
КонецФункции

Процедура ЗаписатьЗначениеJDTOВФайл(Значение, ИмяФайла) Экспорт
	ПараметрыJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, " ", Истина);
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.ОткрытьФайл(ИмяФайла, "UTF-8", , ПараметрыJSON);
	СериализаторXDTO.ЗаписатьJSON(ЗаписьJSON, Значение, НазначениеТипаXML.Явное);
	ЗаписьJSON.Закрыть();
КонецПроцедуры

#КонецЕсли

#КонецОбласти

// Возвращает массив в свойств. Требования к свойствам такие же как при объявлении структуры.
// 
// Параметры:
//	Значение	- Строка - свойства через запятую, которые преобразуются в массив 
//              - Массив из Произвольный - возвращается в исходном значении
// Возвращаемое значение:
//	Массив из Строка - свойства
//	Массив из Произвольный - исходный
//
Функция Массив(Значение) Экспорт
	ТипЗначения = ТипЗнч(Значение);
	Если ТипЗначения = Тип("Массив") Тогда
		Возврат Значение;
	КонецЕсли;
	Если ТипЗначения = Тип("Строка") И НЕ ПустаяСтрока(Значение) Тогда
		Возврат СтрРазделить(СтрЗаменить(СтрЗаменить(Значение, " ", ""), Символы.ПС, ""), ",", Ложь);
	КонецЕсли;
	Возврат Новый Массив;
КонецФункции

// Возвращает значение второго параметра в случае, если значение первого параметра NULL.
// В противном случае будет возвращено значение первого параметра
//
// Параметры:
//  ПроверяемоеЗначение  - Произвольный - проверяемое значение
//  ВозвращаемоеЗначение - произвольный - возвращаемое значение, если значение ПроверяемоеЗначение есть NULL
//
// Возвращаемое значение:
//  Произвольный - если не NULL, то ПроверяемоеЗначение, иначе - ВозвращаемоеЗначение
//
Функция ЕстьNull(ПроверяемоеЗначение, ВозвращаемоеЗначение) Экспорт
	Если ПроверяемоеЗначение = Null Тогда
		Возврат ВозвращаемоеЗначение;
	Иначе
		Возврат ПроверяемоеЗначение;
	КонецЕсли;
КонецФункции

// Возвращает значение второго параметра в случае, если значение первого параметра не заполнено.
// В противном случае будет возвращено значение первого параметра
//
// Параметры:
//  ПроверяемоеЗначение  - Произвольный - проверяемое значение
//  ВозвращаемоеЗначение - произвольный - возвращаемое значение, если значение ПроверяемоеЗначение не заполнено
//
// Возвращаемое значение:
//  Произвольный - если не заполнено, то ПроверяемоеЗначение, иначе - ВозвращаемоеЗначение
//
Функция ЕстьПустоеЗначение(ПроверяемоеЗначение, ВозвращаемоеЗначение) Экспорт
	Если Не ЗначениеЗаполнено(ПроверяемоеЗначение) Тогда
		Возврат ВозвращаемоеЗначение;
	Иначе
		Возврат ПроверяемоеЗначение;
	КонецЕсли;
КонецФункции

Функция ЭтоJSON(СтрокаJSON) Экспорт
	Если ТипЗнч(СтрокаJSON) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	ПервыйСимвол = Лев(СтрокаJSON, 1);
	Если ПервыйСимвол = "{" ИЛИ ПервыйСимвол = "[" Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции

Функция ЭтоСтруктураJSON(СтрокаJSON) Экспорт
	Если ТипЗнч(СтрокаJSON) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	ПервыйСимвол = Лев(СтрокаJSON, 1);
	Если ПервыйСимвол = "{" Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции

Функция ЭтоМассивJSON(СтрокаJSON) Экспорт
	Если ТипЗнч(СтрокаJSON) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	ПервыйСимвол = Лев(СтрокаJSON, 1);
	Если ПервыйСимвол = "[" Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции

// Устанавливает значение переданной переменной только если есть различие. Возвращает различие
// 
// Параметры:
//  СсылкаНаЗначение - Произвольный - Ссылка на значение
//  Значение - Произвольный
//  ЗаполнятьПустое - Булево
//  СохранятьТип - Булево
// 
// Возвращаемое значение:
//  Булево - значение было изменено
Функция УстановитьЗначение(СсылкаНаЗначение, Значение, ЗаполнятьПустое = Истина, СохранятьТип = Ложь) Экспорт
	Если Ложь
		ИЛИ СсылкаНаЗначение = Значение
		ИЛИ (Истина
			И НЕ ЗаполнятьПустое
			И НЕ ЗначениеЗаполнено(Значение)
		)
	Тогда
		Возврат Ложь;
	КонецЕсли;
	ТипСсылки = ТипЗнч(СсылкаНаЗначение);
	Если ТипСсылки = Неопределено Тогда
		СсылкаНаЗначение = Значение;
		Возврат Истина;
	КонецЕсли;
	ТипЗначения = ТипЗнч(Значение);
	Если Истина
		И (Ложь 
			ИЛИ ТипСсылки = Тип("Структура") 
			ИЛИ ТипСсылки = Тип("ФиксированнаяСтруктура") 
		)
		И (Ложь 
			ИЛИ ТипЗначения = Тип("Структура") 
			ИЛИ ТипЗначения = Тип("ФиксированнаяСтруктура") 
		)
	Тогда
		Если СтруктурыИдентичны(СсылкаНаЗначение, Значение) Тогда
			Возврат Ложь;
		КонецЕсли;
		СсылкаНаЗначение = Значение;
		Возврат Истина;
	КонецЕсли;
	Если ТипСсылки = ТипЗначения ИЛИ НЕ СохранятьТип Тогда
		СсылкаНаЗначение = Значение;
		Возврат Истина;
	КонецЕсли;			
	ОписаниеТипа = Новый ОписаниеТипов(ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ТипСсылки));
	ПриведенноеЗначение = ОписаниеТипа.ПривестиЗначение(Значение);
	Если СсылкаНаЗначение = ПриведенноеЗначение Тогда
		Возврат Ложь;	
	КонецЕсли;
	СсылкаНаЗначение = ПриведенноеЗначение;
	Возврат Истина;
КонецФункции

#КонецОбласти
